/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => H2WordCountPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var DEFAULT_SETTINGS = {
  showWords: true,
  showChars: true,
  showPage: false,
  showReadingTime: false,
  showH1: false,
  showH2: true,
  showH3: false
};
var currentSettings = Object.assign({}, DEFAULT_SETTINGS);
var H2WordCountPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    currentSettings = this.settings;
    this.registerEditorExtension(h2WordCountField);
    this.addSettingTab(new H2WordCountSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    currentSettings = this.settings;
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view.getViewType() === "markdown") {
        const view = leaf.view;
        const cm = view.editor.cm;
        if (cm) {
          cm.dispatch();
        }
      }
    });
  }
};
var H2WordCountSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Display Options" });
    new import_obsidian.Setting(containerEl).setName("Words").setDesc("Show word count").addToggle((toggle) => toggle.setValue(this.plugin.settings.showWords).onChange(async (value) => {
      this.plugin.settings.showWords = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Characters").setDesc("Show character count").addToggle((toggle) => toggle.setValue(this.plugin.settings.showChars).onChange(async (value) => {
      this.plugin.settings.showChars = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Pages").setDesc("Show page count (300 words per page)").addToggle((toggle) => toggle.setValue(this.plugin.settings.showPage).onChange(async (value) => {
      this.plugin.settings.showPage = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Reading Time").setDesc("Show estimated reading time").addToggle((toggle) => toggle.setValue(this.plugin.settings.showReadingTime).onChange(async (value) => {
      this.plugin.settings.showReadingTime = value;
      await this.plugin.saveSettings();
    }));

    containerEl.createEl("h3", { text: "Header Levels" });

    new import_obsidian.Setting(containerEl)
      .setName("H1")
      .setDesc("Show word count for H1 headers")
      .addToggle((toggle) => toggle
        .setValue(this.plugin.settings.showH1)
        .onChange(async (value) => {
          this.plugin.settings.showH1 = value;
          await this.plugin.saveSettings();
        }));

    new import_obsidian.Setting(containerEl)
      .setName("H2")
      .setDesc("Show word count for H2 headers")
      .addToggle((toggle) => toggle
        .setValue(this.plugin.settings.showH2)
        .onChange(async (value) => {
          this.plugin.settings.showH2 = value;
          await this.plugin.saveSettings();
        }));

    new import_obsidian.Setting(containerEl)
      .setName("H3")
      .setDesc("Show word count for H3 headers")
      .addToggle((toggle) => toggle
        .setValue(this.plugin.settings.showH3)
        .onChange(async (value) => {
          this.plugin.settings.showH3 = value;
          await this.plugin.saveSettings();
        }));

    const donationDiv = containerEl.createDiv();
    donationDiv.style.marginTop = "40px";
    donationDiv.style.textAlign = "center";
    donationDiv.createEl("p", {
      text: "If this plugin adds value for you and you would like to help support continued development, please use the buttons below:"
    });
    const link = donationDiv.createEl("a", {
      href: "https://buymeacoffee.com/ideo2004c"
    });
    const img = link.createEl("img");
    img.src = "https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png";
    img.alt = "Buy Me A Coffee";
    img.style.height = "60px";
    img.style.width = "217px";
  }
};
var WordCountWidget = class extends import_view.WidgetType {
  constructor(wordCount, charCount) {
    super();
    this.wordCount = wordCount;
    this.charCount = charCount;
  }
  toDOM(view) {
    const span = document.createElement("span");
    span.addClass("h2-word-count-widget");
    const parts = [];
    if (currentSettings.showWords) {
      parts.push(`${this.formatNumber(this.wordCount)} words`);
    }
    if (currentSettings.showChars) {
      parts.push(`${this.formatNumber(this.charCount)} characters`);
    }
    if (currentSettings.showPage) {
      const pages = Math.ceil(this.wordCount / 300);
      parts.push(`${this.formatNumber(pages)} pages`);
    }
    if (currentSettings.showReadingTime) {
      const minutes = Math.ceil(this.wordCount / 275);
      parts.push(`${minutes} min read`);
    }
    if (parts.length > 0) {
      span.textContent = `(${parts.join(" / ")})`;
    } else {
      span.style.display = "none";
    }
    return span;
  }
  formatNumber(num) {
    return num.toLocaleString();
  }
};
var h2WordCountField = import_state.StateField.define({
  create(state) {
    return computeWordCounts(state);
  },
  update(oldState, transaction) {
    if (transaction.docChanged || transaction.selection) {
      return computeWordCounts(transaction.state);
    }
    return oldState;
  },
  provide: (field) => import_view.EditorView.decorations.from(field)
});
function computeWordCounts(state) {
  const builder = new import_state.RangeSetBuilder();
  const doc = state.doc;
  const lines = doc.lines;

  // Active headers for H1, H2, H3 (indices 1, 2, 3)
  // [null, H1_Obj, H2_Obj, H3_Obj]
  let activeHeaders = [null, null, null, null];
  let decorationsBuffer = [];

  const closeHeader = (level, endOffset) => {
    const active = activeHeaders[level];
    if (!active)
      return;
    const contentStart = Math.min(doc.length, active.to + 1);
    const contentEnd = Math.min(doc.length, endOffset);
    let words = 0;
    let chars = 0;
    if (contentStart < contentEnd) {
      const sectionText = doc.sliceString(contentStart, contentEnd);
      words = countWords(sectionText);
      chars = sectionText.length;
    }
    const widget = import_view.Decoration.widget({
      widget: new WordCountWidget(words, chars),
      side: 1
    });
    decorationsBuffer.push({ pos: active.linePos, widget });
    activeHeaders[level] = null;
  };

  for (let i = 1; i <= lines; i++) {
    const line = doc.line(i);
    const text = line.text;

    let level = 0;
    if (text.startsWith("# ")) level = 1;
    else if (text.startsWith("## ")) level = 2;
    else if (text.startsWith("### ")) level = 3;

    if (level > 0) {
      // Close open headers of same or lower rank (i.e. larger level numbers)
      // Actually, H1 should close current H1, H2, H3
      // H2 should close current H2, H3
      // H3 should close current H3
      // So loop from 3 down to current level
      for (let l = 3; l >= level; l--) {
        if (activeHeaders[l]) {
          closeHeader(l, line.from);
        }
      }

      // Check if enabled
      let enabled = false;
      if (level === 1) enabled = currentSettings.showH1;
      else if (level === 2) enabled = currentSettings.showH2;
      else if (level === 3) enabled = currentSettings.showH3;

      if (enabled) {
        activeHeaders[level] = {
          from: line.from,
          to: line.to,
          linePos: line.to
        };
      }
    }
  }

  // Close remaining
  for (let l = 1; l <= 3; l++) {
    if (activeHeaders[l]) {
      closeHeader(l, doc.length);
    }
  }

  decorationsBuffer.sort((a, b) => a.pos - b.pos);
  for (const d of decorationsBuffer) {
    builder.add(d.pos, d.pos, d.widget);
  }
  return builder.finish();
}
function countWords(str) {
  let cjkCount = 0;
  const cjkRegex = /[\u4E00-\u9FFF\u3400-\u4DBF\uF900-\uFAFF]/g;
  const textWithoutCJK = str.replace(cjkRegex, () => {
    cjkCount++;
    return " ";
  });
  const englishWords = textWithoutCJK.match(/\S+/g);
  const enWordCount = englishWords ? englishWords.length : 0;
  return cjkCount + enWordCount;
}
